{"version":3,"sources":["../../src/ts/headerRendering/cssClassApplier.ts"],"names":[],"mappings":";;;;;;;;AAKA,4CAA2C;AAC3C,oCAA2C;AAE3C;IAAA;IAmDA,CAAC;IAjDiB,0CAA0B,GAAxC,UAAyC,cAA8B,EAAE,WAAwB,EAAE,kBAAsC,EAAE,MAAc,EAAE,WAAwB;QAC/K,IAAI,iBAAO,CAAC,cAAc,CAAC,EAAE;YACzB,OAAO;SACV;QACD,IAAI,CAAC,2BAA2B,CAAC,cAAc,CAAC,WAAW,EAAE,cAAc,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;IACvI,CAAC;IAEa,6CAA6B,GAA3C,UAA4C,cAA8B,EAAE,WAAwB,EAAE,kBAAsC,EAAE,MAAqB,EAAE,WAAuC;QACxM,IAAI,iBAAO,CAAC,cAAc,CAAC,EAAE;YACzB,OAAO;SACV;QACD,IAAI,CAAC,2BAA2B,CAAC,cAAc,CAAC,cAAc,EAAE,cAAc,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;IAC1I,CAAC;IAEa,2CAA2B,GAAzC,UAA0C,aAAuE,EACvE,cAA8B,EAC9B,WAAwB,EACxB,kBAAsC,EACtC,MAAc,EACd,WAA8C;QACpF,IAAI,iBAAO,CAAC,aAAa,CAAC,EAAE;YACxB,OAAO;SACV;QACD,IAAI,UAA6B,CAAC;QAClC,IAAI,OAAO,aAAa,KAAK,UAAU,EAAE;YACrC,IAAM,MAAM,GAAG;gBACX,yDAAyD;gBACzD,uDAAuD;gBACvD,8CAA8C;gBAC9C,MAAM,EAAE,cAAc;gBACtB,MAAM,EAAE,MAAM;gBACd,WAAW,EAAE,WAAW;gBACxB,OAAO,EAAE,kBAAkB,CAAC,UAAU,EAAE;gBACxC,GAAG,EAAE,kBAAkB,CAAC,MAAM,EAAE;aACnC,CAAC;YACF,IAAM,eAAe,GAAG,aAAmD,CAAC;YAC5E,UAAU,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;SACxC;aAAM;YACH,UAAU,GAAG,aAAkC,CAAC;SACnD;QAED,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAChC,iBAAW,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;SACxC;aAAM,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YAClC,UAAU,CAAC,OAAO,CAAC,UAAC,YAAiB;gBACjC,iBAAW,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;YAC3C,CAAC,CAAC,CAAC;SACN;IACL,CAAC;IACL,sBAAC;AAAD,CAnDA,AAmDC,IAAA;AAnDY,0CAAe","file":"cssClassApplier.js","sourcesContent":["import { AbstractColDef } from \"../entities/colDef\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ColumnGroup } from \"../entities/columnGroup\";\nimport { Column } from \"../entities/column\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { missing } from \"../utils/generic\";\nimport { addCssClass } from \"../utils/dom\";\n\nexport class CssClassApplier {\n\n    public static addHeaderClassesFromColDef(abstractColDef: AbstractColDef, eHeaderCell: HTMLElement, gridOptionsWrapper: GridOptionsWrapper, column: Column, columnGroup: ColumnGroup) {\n        if (missing(abstractColDef)) {\n            return;\n        }\n        this.addColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);\n    }\n\n    public static addToolPanelClassesFromColDef(abstractColDef: AbstractColDef, eHeaderCell: HTMLElement, gridOptionsWrapper: GridOptionsWrapper, column: Column | null, columnGroup: OriginalColumnGroup | null) {\n        if (missing(abstractColDef)) {\n            return;\n        }\n        this.addColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);\n    }\n\n    public static addColumnClassesFromCollDef(classesOrFunc: string | string[] | ((params: any) => string | string[]),\n                                              abstractColDef: AbstractColDef,\n                                              eHeaderCell: HTMLElement,\n                                              gridOptionsWrapper: GridOptionsWrapper,\n                                              column: Column,\n                                              columnGroup: ColumnGroup | OriginalColumnGroup) {\n        if (missing(classesOrFunc)) {\n            return;\n        }\n        let classToUse: string | string[];\n        if (typeof classesOrFunc === 'function') {\n            const params = {\n                // bad naming, as colDef here can be a group or a column,\n                // however most people won't appreciate the difference,\n                // so keeping it as colDef to avoid confusion.\n                colDef: abstractColDef,\n                column: column,\n                columnGroup: columnGroup,\n                context: gridOptionsWrapper.getContext(),\n                api: gridOptionsWrapper.getApi()\n            };\n            const headerClassFunc = classesOrFunc as (params: any) => string | string[];\n            classToUse = headerClassFunc(params);\n        } else {\n            classToUse = classesOrFunc as string | string[];\n        }\n\n        if (typeof classToUse === 'string') {\n            addCssClass(eHeaderCell, classToUse);\n        } else if (Array.isArray(classToUse)) {\n            classToUse.forEach((cssClassItem: any): void => {\n                addCssClass(eHeaderCell, cssClassItem);\n            });\n        }\n    }\n}"]}