{"version":3,"sources":["../../src/ts/columnController/columnFactory.ts"],"names":[],"mappings":"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","file":"columnFactory.js","sourcesContent":["import { GridOptionsWrapper } from '../gridOptionsWrapper';\nimport { Logger, LoggerFactory } from '../logger';\nimport { ColumnUtils } from './columnUtils';\nimport {AbstractColDef, ColDef, ColGroupDef} from \"../entities/colDef\";\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { OriginalColumnGroupChild } from \"../entities/originalColumnGroupChild\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { Constants } from \"../constants/constants\";\nimport { assign, iterateObject, mergeDeep } from '../utils/object';\nimport { attrToNumber, attrToBoolean, find } from '../utils/generic';\nimport { removeFromArray } from '../utils/array';\n\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n@Bean('columnFactory')\nexport class ColumnFactory extends BeanStub {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('columnUtils') private columnUtils: ColumnUtils;\n\n    private logger: Logger;\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    }\n\n    public createColumnTree(defs: (ColDef | ColGroupDef)[] | null, primaryColumns: boolean, existingColumns?: Column[])\n        : { columnTree: OriginalColumnGroupChild[], treeDept: number; } {\n\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        const columnKeyCreator = new ColumnKeyCreator();\n\n        if (existingColumns) {\n            const existingKeys: string[] = existingColumns.map(col => col.getId());\n            columnKeyCreator.addExistingKeys(existingKeys);\n        }\n\n        // we take a copy of the columns as we are going to be removing from them\n        const existingColsCopy = existingColumns ? existingColumns.slice() : null;\n\n        // create am unbalanced tree that maps the provided definitions\n        const unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns,\n            existingColsCopy, columnKeyCreator, null);\n        const treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n        const deptFirstCallback = (child: OriginalColumnGroupChild, parent: OriginalColumnGroup) => {\n            if (child instanceof OriginalColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n\n        this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n\n        return {\n            columnTree,\n            treeDept\n        };\n    }\n\n    public createForAutoGroups(autoGroupCols: Column[] | null, gridBalancedTree: OriginalColumnGroupChild[]): OriginalColumnGroupChild[] {\n        const autoColBalancedTree: OriginalColumnGroupChild[] = [];\n        autoGroupCols.forEach(col => {\n            const fakeTreeItem = this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n\n        return autoColBalancedTree;\n    }\n\n    private createAutoGroupTreeItem(balancedColumnTree: OriginalColumnGroupChild[], column: Column): OriginalColumnGroupChild {\n\n        const dept = this.findDepth(balancedColumnTree);\n\n        // at the end, this will be the top of the tree item.\n        let nextChild: OriginalColumnGroupChild = column;\n\n        for (let i = dept - 1; i >= 0; i--) {\n            const autoGroup = new OriginalColumnGroup(\n                null,\n                `FAKE_PATH_${column.getId()}}_${i}`,\n                true,\n                i\n            );\n            this.context.createBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    }\n\n    private findDepth(balancedColumnTree: OriginalColumnGroupChild[]): number {\n        let dept = 0;\n        let pointer = balancedColumnTree;\n\n        while (pointer && pointer[0] && pointer[0] instanceof OriginalColumnGroup) {\n            dept++;\n            pointer = (pointer[0] as OriginalColumnGroup).getChildren();\n        }\n        return dept;\n    }\n\n    private balanceColumnTree(\n        unbalancedTree: OriginalColumnGroupChild[],\n        currentDept: number,\n        columnDept: number,\n        columnKeyCreator: ColumnKeyCreator\n    ): OriginalColumnGroupChild[] {\n\n        const result: OriginalColumnGroupChild[] = [];\n\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (let i = 0; i < unbalancedTree.length; i++) {\n            const child = unbalancedTree[i];\n            if (child instanceof OriginalColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                const originalGroup = child;\n                const newChildren = this.balanceColumnTree(originalGroup.getChildren(),\n                    currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            } else {\n                // child is a column - so here we add in the padded column groups if needed\n                let firstPaddedGroup: OriginalColumnGroup | undefined;\n                let currentPaddedGroup: OriginalColumnGroup | undefined;\n\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (let j = columnDept - 1; j >= currentDept; j--) {\n                    const newColId = columnKeyCreator.getUniqueKey(null, null);\n                    const colGroupDefMerged = this.createMergedColGroupDef(null);\n\n                    const paddedGroup = new OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.createBean(paddedGroup);\n\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n\n                    currentPaddedGroup = paddedGroup;\n\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    const hasGroups = unbalancedTree.some(child => child instanceof OriginalColumnGroup);\n\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    } else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n\n                result.push(child);\n            }\n        }\n\n        return result;\n    }\n\n    private findMaxDept(treeChildren: OriginalColumnGroupChild[], dept: number): number {\n        let maxDeptThisLevel = dept;\n\n        for (let i = 0; i < treeChildren.length; i++) {\n            const abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof OriginalColumnGroup) {\n                const originalGroup = abstractColumn;\n                const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n\n        return maxDeptThisLevel;\n    }\n\n    private recursivelyCreateColumns(\n        defs: (ColDef | ColGroupDef)[],\n        level: number,\n        primaryColumns: boolean,\n        existingColsCopy: Column[],\n        columnKeyCreator: ColumnKeyCreator,\n        parent: OriginalColumnGroup | null\n    ): OriginalColumnGroupChild[] {\n\n        const result: OriginalColumnGroupChild[] = [];\n\n        if (!defs) { return result; }\n\n        defs.forEach((def: ColDef | ColGroupDef) => {\n            let newGroupOrColumn: OriginalColumnGroupChild;\n\n            if (this.isColumnGroup(def)) {\n                newGroupOrColumn = this.createColumnGroup(primaryColumns, def as ColGroupDef, level, existingColsCopy,\n                    columnKeyCreator, parent);\n            } else {\n                newGroupOrColumn = this.createColumn(primaryColumns, def as ColDef, existingColsCopy, columnKeyCreator, parent);\n            }\n\n            result.push(newGroupOrColumn);\n        });\n\n        return result;\n    }\n\n    private createColumnGroup(\n        primaryColumns: boolean,\n        colGroupDef: ColGroupDef,\n        level: number,\n        existingColumns: Column[],\n        columnKeyCreator: ColumnKeyCreator,\n        parent: OriginalColumnGroup | null\n    ): OriginalColumnGroup {\n        const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n        const originalGroup = new OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n\n        this.context.createBean(originalGroup);\n\n        const children = this.recursivelyCreateColumns(colGroupDefMerged.children,\n            level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n\n        originalGroup.setChildren(children);\n\n        return originalGroup;\n    }\n\n    private createMergedColGroupDef(colGroupDef: ColGroupDef): ColGroupDef {\n        const colGroupDefMerged: ColGroupDef = {} as ColGroupDef;\n        assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n\n        return colGroupDefMerged;\n    }\n\n    private createColumn(\n        primaryColumns: boolean,\n        colDef: ColDef,\n        existingColsCopy: Column[],\n        columnKeyCreator: ColumnKeyCreator,\n        parent: OriginalColumnGroup | null\n    ): Column {\n        const colDefMerged = this.mergeColDefs(colDef);\n\n        this.checkForDeprecatedItems(colDefMerged);\n\n        // see if column already exists\n        let column = this.findExistingColumn(colDef, existingColsCopy);\n\n        if (!column) {\n            // no existing column, need to create one\n            const colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.createBean(column);\n        } else {\n            column.setColDef(colDefMerged, colDef);\n            this.applyColumnState(column, colDefMerged);\n        }\n\n        return column;\n    }\n\n    private applyColumnState(column: Column, colDef: ColDef): void {\n        // flex\n        const flex = attrToNumber(colDef.flex);\n        if (flex !== undefined) {\n            column.setFlex(flex);\n        }\n\n        // width - we only set width if column is not flexing\n        const noFlexThisCol = column.getFlex() <= 0;\n        if (noFlexThisCol) {\n            // both null and undefined means we skip, as it's not possible to 'clear' width (a column must have a width)\n            const width = attrToNumber(colDef.width);\n            if (width != null) {\n                column.setActualWidth(width);\n            }\n        }\n\n        // sort - anything but undefined will set sort, thus null or empty string will clear the sort\n        if (colDef.sort !== undefined) {\n            if (colDef.sort == Constants.SORT_ASC || colDef.sort == Constants.SORT_DESC) {\n                column.setSort(colDef.sort);\n            } else {\n                column.setSort(undefined);\n            }\n        }\n\n        // sorted at - anything but undefined, thus null will clear the sortIndex\n        const sortIndex = attrToNumber(colDef.sortIndex);\n        if (sortIndex !== undefined) {\n            column.setSortIndex(sortIndex);\n        }\n\n        // hide - anything but undefined, thus null will clear the hide\n        const hide = attrToBoolean(colDef.hide);\n        if (hide !== undefined) {\n            column.setVisible(!hide);\n        }\n\n        // pinned - anything but undefined, thus null or empty string will remove pinned\n        if (colDef.pinned !== undefined) {\n            column.setPinned(colDef.pinned);\n        }\n    }\n\n    public findExistingColumn(newColDef: ColDef, existingColsCopy: Column[]): Column {\n        const res: Column = find(existingColsCopy, existingCol => {\n\n            const existingColDef = existingCol.getUserProvidedColDef();\n            if (!existingColDef) { return false; }\n\n            const newHasId = newColDef.colId != null;\n            const newHasField = newColDef.field != null;\n\n            if (newHasId) {\n                return existingCol.getId() === newColDef.colId;\n            }\n\n            if (newHasField) {\n                return existingColDef.field === newColDef.field;\n            }\n\n            // if no id or field present, then try object equivalence.\n            if (existingColDef === newColDef) { return true; }\n\n            return false;\n        });\n\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            removeFromArray(existingColsCopy, res);\n        }\n\n        return res;\n    }\n\n    public mergeColDefs(colDef: ColDef) {\n        // start with empty merged definition\n        const colDefMerged: ColDef = {} as ColDef;\n\n        // merge properties from default column definitions\n        const defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n        mergeDeep(colDefMerged, defaultColDef, true, true);\n\n        // merge properties from column type properties\n        if (colDef.type || (defaultColDef && defaultColDef.type)) {\n            // if type of both colDef and defaultColDef, then colDef gets preference\n            const columnType = colDef.type ? colDef.type : defaultColDef.type;\n            this.assignColumnTypes(columnType, colDefMerged);\n        }\n\n        // merge properties from column definitions\n        mergeDeep(colDefMerged, colDef, true, true);\n\n        return colDefMerged;\n    }\n\n    private assignColumnTypes(type: string | string[], colDefMerged: ColDef) {\n        let typeKeys: string[];\n\n        if (type instanceof Array) {\n            const invalidArray = type.some(a => typeof a !== 'string');\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            } else {\n                typeKeys = type;\n            }\n        } else if (typeof type === 'string') {\n            typeKeys = type.split(',');\n        } else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n\n        // merge user defined with default column types\n        const allColumnTypes = assign({}, DefaultColumnTypes);\n        const userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n\n        iterateObject(userTypes, (key, value) => {\n            if (key in allColumnTypes) {\n                console.warn(`ag-Grid: the column type '${key}' is a default column type and cannot be overridden.`);\n            } else {\n                allColumnTypes[key] = value;\n            }\n        });\n\n        typeKeys.forEach((t) => {\n            const typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                mergeDeep(colDefMerged, typeColDef, true, true);\n            } else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    }\n\n    private checkForDeprecatedItems(colDef: AbstractColDef) {\n        if (colDef) {\n            const colDefNoType = colDef as any; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    }\n\n    // if object has children, we assume it's a group\n    private isColumnGroup(abstractColDef: ColDef | ColGroupDef): boolean {\n        return (abstractColDef as ColGroupDef).children !== undefined;\n    }\n}\n"]}